#include "system.h"

/* Defines a GDT entry. We say packed, because it prevents the
*  compiler from doing things that it thinks is best: Prevent
*  compiler "optimization" by packing */

struct GDTEntry
{
    WORD limit_1;			// segment limit bits 0->15
    WORD base_1;		// segment base address bits 0->15
	BYTE base_2;			// segment base address bits 16->23
    
	BYTE type:4;			// segment type
	BYTE system:1;		// descriptor type
	BYTE dpl:2;				// descriptor privilige level
	BYTE present:1;		// segment present in memory
	
    BYTE limit_2:4;			// segment limit bits 16->19
	BYTE avl:1;				// available bit
	BYTE zero:1;			// zero field for 32 bit architecture
	BYTE db:1;				// D/B field
	BYTE granularity:1;	// Granularity field
	
    BYTE base_3;			// segment base address bits 24->31
} __attribute__((packed)); /* this attribute ensures the structure generated by the compiler
												will be exactly the same size as the above (ie no optimization)    */

// Structure to be loaded into the GDTR using lgdt insruction
struct GDTR {
    WORD limit;
    DWORD base;
} __attribute__((packed));

// Declare a GDT with 3 entries, and the GDT pointer 
#define MAX_ENTRIES 3
GDTEntry gdt[MAX_ENTRIES];
GDTR gptr;


void setGDTEntry(int num,  bool isCode, int dpl)
{	if(num>= MAX_ENTRIES)
		return;
    // Setup the descriptor base address: 0
    gdt[num].base_1 = 0;
    gdt[num].base_2 = 0;
    gdt[num].base_3 = 0;

    // Setup the descriptor limits : 0xFFFFF (*4 ko see granularity flag)
    gdt[num].limit_1 = 0xFFFF;
    gdt[num].limit_2 = 0xF;

    // setup flags
	gdt[num].type = (isCode)?0xb:0x3;	// if isCode=true -> type=code (0xb) oterwise type=data(3)
    gdt[num].system = 1;							// decriptor type = code/data
    gdt[num].dpl = (dpl & 3);					// same as (dpl modulo 3+1) to ensure dpl always <= 3
    gdt[num].present = 1;
	
	gdt[num].avl = 0;
    gdt[num].db = 1;								// D/B: 32 bit segment type
	gdt[num].zero = 0;
	gdt[num].granularity = 1;
}




/* Called by main. This will setup our proeper GDT
*  setup the first 3 entries, and then setup the GDTR stucture
*  finally load the gdt int the GDTR using inline assembly  */
void GDTSetup()
{
    /* Setup the GDT pointer and limit */
    gptr.limit = (sizeof(GDTEntry) * MAX_ENTRIES)-1 ;
    gptr.base = (DWORD)&gdt;
	
	
	//First gdt entry must be null
	BYTE *entry = reinterpret_cast<BYTE*>(gdt);
	memset(entry, 0, sizeof(GDTEntry));

    // setup a code segment with dpl=0
    setGDTEntry(1, true, 0);

    // setup a data segment with dpl=0
    setGDTEntry(2, false, 0);
	
	//load the new GDT into GDTR and then update the segment registers
	asm volatile ("lgdt %0          \n\
			 ljmp $8,$1f      \n\
			 1:               \n\
			 movw $16, %%ax    \n\
			 movw %%ax,  %%ss \n\
			 movw %%ax,  %%ds \n\
			 movw %%ax,  %%es \n\
			 movw %%ax,  %%fs \n\
			 movw %%ax,  %%gs"
		:: "m"(gptr));
}
